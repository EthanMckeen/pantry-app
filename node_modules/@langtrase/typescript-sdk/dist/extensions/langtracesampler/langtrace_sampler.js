"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LangtraceSampler = void 0;
const api_1 = require("@opentelemetry/api");
const sdk_trace_base_1 = require("@opentelemetry/sdk-trace-base");
class LangtraceSampler {
    constructor(disabled_functions) {
        this._disabled_function_names = new Set();
        for (const key in disabled_functions) {
            if (disabled_functions[key] !== undefined) {
                const functions = disabled_functions[key];
                functions.forEach((method) => {
                    this._disabled_function_names.add(method);
                });
            }
        }
    }
    shouldSample(context, traceId, spanName, spanKind, attributes) {
        // Check if the span name is in the list of method names to skip
        if (this._disabled_function_names.has(spanName)) {
            api_1.diag.info('Skipping sampling span(s) related to %s as it\'s disabled', spanName);
            return { decision: sdk_trace_base_1.SamplingDecision.NOT_RECORD };
        }
        // Check the specific attribute
        if (attributes['langtrace.sdk.name'] !== '@langtrase/typescript-sdk') {
            api_1.diag.info('Skipping sampling span(s) related to %s as it\'s not from Langtrace', spanName);
            return { decision: sdk_trace_base_1.SamplingDecision.RECORD };
        }
        // If parent span is not recorded, propagate the decision to child spans
        // None means no sampling decision has been made. If the parent span is not sampled, the child span should not be sampled.
        const childSpan = api_1.trace.getSpan(context);
        const spanSourceIsUnknown = childSpan?.isRecording() === true && childSpan.spanContext().traceFlags === api_1.TraceFlags.NONE;
        if ((childSpan != null) && childSpan.spanContext().traceFlags === api_1.TraceFlags.NONE && !spanSourceIsUnknown) {
            return { decision: sdk_trace_base_1.SamplingDecision.NOT_RECORD };
        }
        return { decision: sdk_trace_base_1.SamplingDecision.RECORD_AND_SAMPLED };
    }
}
exports.LangtraceSampler = LangtraceSampler;
//# sourceMappingURL=langtrace_sampler.js.map