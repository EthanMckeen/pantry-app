"use strict";
/*
 * Copyright (c) 2024 Scale3 Labs
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.init = void 0;
const sdk_trace_node_1 = require("@opentelemetry/sdk-trace-node");
const instrumentation_1 = require("@opentelemetry/instrumentation");
const sdk_trace_base_1 = require("@opentelemetry/sdk-trace-base");
const langtrace_exporter_1 = require("../extensions/langtraceexporter/langtrace_exporter");
const langtrace_sampler_1 = require("../extensions/langtracesampler/langtrace_sampler");
const langtrace_exporter_2 = require("../constants/exporter/langtrace_exporter");
const instrumentation_2 = require("../instrumentation/anthropic/instrumentation");
const instrumentation_3 = require("../instrumentation/chroma/instrumentation");
const instrumentation_4 = require("../instrumentation/cohere/instrumentation");
const instrumentation_5 = require("../instrumentation/groq/instrumentation");
const instrumentation_6 = require("../instrumentation/llamaindex/instrumentation");
const instrumentation_7 = require("../instrumentation/openai/instrumentation");
const instrumentation_8 = require("../instrumentation/pinecone/instrumentation");
const instrumentation_9 = require("../instrumentation/qdrant/instrumentation");
const api_1 = require("@opentelemetry/api");
const instrumentation_10 = require("../instrumentation/weaviate/instrumentation");
const misc_1 = require("../utils/misc");
const ansi_colors_1 = __importDefault(require("ansi-colors"));
const instrumentation_11 = require("../instrumentation/pg/instrumentation");
const instrumentation_12 = require("../instrumentation/ollama/instrumentation");
const instrumentation_13 = require("../instrumentation/vercel/instrumentation");
/**
 * Initializes the LangTrace sdk with custom options.
 *
 * @param api_key API key for Langtrace.
 * @param batch Whether to batch spans before exporting.
 *      This helps in reducing the number of requests made to the server.
 * @param write_spans_to_console Whether to write spans to Langtrace cloud.
 *      Enables direct storage of spans in the cloud for accessibility and analysis.
 * @param custom_remote_exporter Custom remote exporter to use.
 *      This allows for customization of the span export process to meet specific needs.
 * @param instrumentations Instrumentations to enable.
 *      This is used for next.js applications as automatic instrumentation is not supported.
 * @param api_host API host to send spans to.
 *      Specifies the destination server for the span data. For self hosted instances, this should be set to <HOSTED_LANGTRACE_URL>/api/trace.
 * @param disable_instrumentations Instrumentations to disable.
 *  - all_except: will disable all instrumentations except the ones specified.
 *  - only: will disable only the instrumentations specified.
 *  - If both 'all_except' and 'only' are specified, an error will be thrown.
 * @param logging Logging configuration.
 *  - level: Log level to use.
 *  - logger: Logger to use.
 *  - disable: Whether to disable logging.
 * @param disable_latest_version_check Whether to disable the check for the latest version of the sdk.
 * @param disable_tracing_for_functions Functions per vendor to disable tracing for.
*/
let isLatestSdk = false;
const init = ({ api_key = undefined, batch = false, write_spans_to_console = false, custom_remote_exporter = undefined, instrumentations = undefined, api_host = langtrace_exporter_2.LANGTRACE_REMOTE_URL, disable_instrumentations = {}, logging = {
    level: api_1.DiagLogLevel.INFO,
    logger: new api_1.DiagConsoleLogger(),
    disable: false
}, disable_latest_version_check = false, disable_tracing_for_functions = undefined } = {}) => {
    const provider = new sdk_trace_node_1.NodeTracerProvider({ sampler: new langtrace_sampler_1.LangtraceSampler(disable_tracing_for_functions) });
    const host = (process.env.LANGTRACE_API_HOST ?? api_host ?? langtrace_exporter_2.LANGTRACE_REMOTE_URL);
    const remoteWriteExporter = new langtrace_exporter_1.LangTraceExporter(api_key ?? process.env.LANGTRACE_API_KEY ?? '', host);
    const consoleExporter = new sdk_trace_base_1.ConsoleSpanExporter();
    const batchProcessorRemote = new sdk_trace_base_1.BatchSpanProcessor(remoteWriteExporter);
    const simpleProcessorRemote = new sdk_trace_base_1.SimpleSpanProcessor(remoteWriteExporter);
    const simpleProcessorConsole = new sdk_trace_base_1.SimpleSpanProcessor(consoleExporter);
    process.env.LANGTRACE_API_HOST = host.replace('/api/trace', '');
    api_1.diag.setLogger(logging.logger ?? new api_1.DiagConsoleLogger(), { suppressOverrideMessage: true, logLevel: logging.level });
    if (logging.disable === true) {
        api_1.diag.disable();
    }
    if (!isLatestSdk && !disable_latest_version_check) {
        void (0, misc_1.getCurrentAndLatestVersion)().then((res) => {
            if (res !== undefined) {
                if (res.latestVersion !== res.currentVersion) {
                    const versionOudatedMessage = `${ansi_colors_1.default.white(`Version ${ansi_colors_1.default.red(res.currentVersion)} is outdated`)}`;
                    const installUpdateMessage = `${ansi_colors_1.default.white(`To update to the latest version ${ansi_colors_1.default.green(res.latestVersion)} run the command below\n\n${ansi_colors_1.default.green('npm uninstall @langtrase/typescript-sdk && npm i @langtrase/typescript-sdk')}`)}`;
                    const message = (0, misc_1.boxText)(`${versionOudatedMessage}\n\n${installUpdateMessage}`);
                    // eslint-disable-next-line no-console
                    console.log(ansi_colors_1.default.yellow(message));
                }
                else {
                    isLatestSdk = true;
                }
            }
        });
    }
    if (api_host === langtrace_exporter_2.LANGTRACE_REMOTE_URL && !write_spans_to_console) {
        if (api_key === undefined && process.env.LANGTRACE_API_KEY === undefined) {
            api_1.diag.warn('No API key provided. Please provide an API key to start sending traces to Langtrace.');
        }
    }
    if (api_key !== undefined) {
        process.env.LANGTRACE_API_KEY = api_key;
    }
    if (write_spans_to_console) {
        provider.addSpanProcessor(simpleProcessorConsole);
    }
    else if (api_host !== undefined && custom_remote_exporter === undefined) {
        if (batch) {
            provider.addSpanProcessor(batchProcessorRemote);
        }
        else {
            provider.addSpanProcessor(simpleProcessorRemote);
        }
    }
    else if (custom_remote_exporter !== undefined) {
        if (batch) {
            provider.addSpanProcessor(new sdk_trace_base_1.BatchSpanProcessor(custom_remote_exporter));
        }
        else {
            provider.addSpanProcessor(new sdk_trace_base_1.SimpleSpanProcessor(custom_remote_exporter));
        }
    }
    if (!global.langtrace_initalized) {
        provider.register();
    }
    const allInstrumentations = {
        openai: instrumentation_7.openAIInstrumentation,
        cohere: instrumentation_4.cohereInstrumentation,
        anthropic: instrumentation_2.anthropicInstrumentation,
        groq: instrumentation_5.groqInstrumentation,
        pinecone: instrumentation_8.pineconeInstrumentation,
        llamaindex: instrumentation_6.llamaIndexInstrumentation,
        chromadb: instrumentation_3.chromaInstrumentation,
        qdrant: instrumentation_9.qdrantInstrumentation,
        weaviate: instrumentation_10.weaviateInstrumentation,
        pg: instrumentation_11.pgInstrumentation,
        ai: instrumentation_13.vercelAIInstrumentation,
        ollama: instrumentation_12.ollamaInstrumentation
    };
    if (instrumentations === undefined) {
        (0, instrumentation_1.registerInstrumentations)({
            instrumentations: Object.values(allInstrumentations).filter((instrumentation) => instrumentation !== undefined),
            tracerProvider: provider
        });
        disableInstrumentations(disable_instrumentations, allInstrumentations);
    }
    else {
        Object.entries(instrumentations).forEach(([key, value]) => {
            if (value !== undefined) {
                allInstrumentations[key].manualPatch(value);
            }
        });
        (0, instrumentation_1.registerInstrumentations)({ tracerProvider: provider });
        disableInstrumentations(disable_instrumentations, allInstrumentations, instrumentations);
    }
    global.langtrace_initalized = true;
};
exports.init = init;
const disableInstrumentations = (disable_instrumentations, allInstrumentations, modules) => {
    if (disable_instrumentations.only !== undefined && disable_instrumentations.all_except !== undefined) {
        throw new Error('Cannot specify both only and all_except in disable_instrumentations');
    }
    const instrumentations = Object.fromEntries(Object.entries(allInstrumentations)
        .filter(([key, instrumentation]) => {
        if (instrumentation === undefined) {
            return false;
        }
        if (disable_instrumentations.all_except !== undefined) {
            if (!disable_instrumentations.all_except.includes(key)) {
                if (modules !== undefined && modules[key] !== undefined) {
                    instrumentation._unpatch(modules[key]);
                }
                else {
                    instrumentation.disable();
                }
                return false;
            }
        }
        if (disable_instrumentations.only !== undefined) {
            if (disable_instrumentations.only.includes(key)) {
                if (modules !== undefined && modules[key] !== undefined) {
                    instrumentation._unpatch(modules[key]);
                }
                else {
                    instrumentation.disable();
                }
            }
        }
        return true;
    }));
    return Object.values(instrumentations);
};
//# sourceMappingURL=init.js.map