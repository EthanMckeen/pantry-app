"use strict";
/* eslint-disable @typescript-eslint/no-unsafe-return */
/*
 * Copyright (c) 2024 Scale3 Labs
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.genericPatch = void 0;
const trace_attributes_1 = require("@langtrase/trace-attributes");
const api_1 = require("@opentelemetry/api");
const common_1 = require("../../constants/common");
function genericPatch(originalMethod, method, tracer, langtraceVersion, version) {
    return async function (...args) {
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const originalContext = this;
        const api = trace_attributes_1.APIS.pinecone[method];
        const customAttributes = api_1.context.active().getValue(common_1.LANGTRACE_ADDITIONAL_SPAN_ATTRIBUTES_KEY) ?? {};
        const attributes = {
            'langtrace.sdk.name': '@langtrase/typescript-sdk',
            'langtrace.service.name': trace_attributes_1.Vendors.PINECONE,
            'langtrace.service.type': 'vectordb',
            'langtrace.service.version': version,
            'langtrace.version': langtraceVersion,
            'db.system': 'pinecone',
            'db.operation': api.OPERATION,
            'db.query': JSON.stringify(args),
            ...customAttributes
        };
        const span = tracer.startSpan(api.METHOD, { kind: api_1.SpanKind.CLIENT, attributes }, api_1.context.active());
        return await api_1.context.with(api_1.trace.setSpan(api_1.context.active(), span), async () => {
            try {
                if (this.target?.index !== undefined) {
                    span.setAttributes({ 'db.index': this.target?.index });
                }
                if (this.target?.namespace !== undefined) {
                    span.setAttributes({ 'db.namespace': this.target?.namespace });
                }
                if (this.target?.indexHostUrl !== undefined) {
                    span.setAttributes({ 'server.address': `${this.target?.indexHostUrl}${api.ENDPOINT}` });
                }
                if (args[0]?.topK !== undefined) {
                    span.setAttributes({ 'db.top_k': args[0]?.topK });
                }
                // Call the original create method
                // NOTE: Not tracing the response data as it can contain sensitive information
                const response = await originalMethod.apply(originalContext, args);
                if (response !== undefined) {
                    span.addEvent(trace_attributes_1.Event.RESPONSE, { 'db.response': JSON.stringify(response) });
                }
                span.setStatus({ code: api_1.SpanStatusCode.OK });
                span.end();
                return response;
            }
            catch (error) {
                // If an error occurs, record the exception and end the span
                span.recordException(error);
                span.setStatus({ code: api_1.SpanStatusCode.ERROR });
                span.end();
                throw error;
            }
        });
    };
}
exports.genericPatch = genericPatch;
//# sourceMappingURL=patch.js.map