"use strict";
/*
 * Copyright (c) 2024 Scale3 Labs
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.genericPatch = void 0;
const common_1 = require("../../constants/common");
const trace_attributes_1 = require("@langtrase/trace-attributes");
const api_1 = require("@opentelemetry/api");
function genericPatch(originalMethod, method, task, tracer, langtraceVersion, version) {
    return async function (...args) {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        const customAttributes = api_1.context.active().getValue(common_1.LANGTRACE_ADDITIONAL_SPAN_ATTRIBUTES_KEY) ?? {};
        const attributes = {
            'langtrace.sdk.name': '@langtrase/typescript-sdk',
            'langtrace.service.name': trace_attributes_1.Vendors.LLAMAINDEX,
            'langtrace.service.type': 'framework',
            'langtrace.service.version': version,
            'langtrace.version': langtraceVersion,
            'llamaindex.task.name': task,
            ...customAttributes
        };
        const span = tracer.startSpan(method, { kind: api_1.SpanKind.CLIENT, attributes }, api_1.context.active());
        return await api_1.context.with(api_1.trace.setSpan(api_1.context.active(), span), async () => {
            try {
                const response = await originalMethod.apply(this, args);
                span.setStatus({ code: api_1.SpanStatusCode.OK });
                span.end();
                return response;
            }
            catch (error) {
                span.recordException(error);
                span.setStatus({ code: api_1.SpanStatusCode.ERROR });
                span.end();
                throw error;
            }
        });
    };
}
exports.genericPatch = genericPatch;
//# sourceMappingURL=patch.js.map