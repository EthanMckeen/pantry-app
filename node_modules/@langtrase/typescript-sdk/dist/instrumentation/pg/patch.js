"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.patchPgQuery = void 0;
const trace_attributes_1 = require("@langtrase/trace-attributes");
const api_1 = require("@opentelemetry/api");
const misc_1 = require("../../utils/misc");
const common_1 = require("../../constants/common");
const patchPgQuery = (original, tracer, sdkName, langtraceVersion, version) => {
    return async function (queryOrTextConfig, values, callback) {
        const customAttributes = api_1.context.active().getValue(common_1.LANGTRACE_ADDITIONAL_SPAN_ATTRIBUTES_KEY) ?? {};
        const attributes = {
            'langtrace.sdk.name': sdkName,
            'langtrace.service.name': trace_attributes_1.Vendors.PG,
            'langtrace.service.type': 'vectordb',
            'langtrace.service.version': version,
            'langtrace.version': langtraceVersion,
            'db.system': 'postgres',
            'db.collection.name': this.connectionParameters.database,
            'server.address': this.connectionParameters.host,
            'db.query': (0, misc_1.stringify)({ queryOrTextConfig, values }),
            ...customAttributes
        };
        const span = tracer.startSpan(trace_attributes_1.APIS.pg.QUERY.METHOD, { kind: api_1.SpanKind.CLIENT, attributes });
        return await api_1.context.with(api_1.trace.setSpan(api_1.context.active(), api_1.trace.getSpan(api_1.context.active()) ?? span), async () => {
            try {
                const resp = await original.apply(this, [queryOrTextConfig, values, callback]);
                attributes['db.operation'] = resp.command;
                attributes['db.top_k'] = resp.rowCount;
                span.setAttributes(attributes);
                if (resp !== undefined)
                    span.addEvent(trace_attributes_1.Event.RESPONSE, { 'db.response': (0, misc_1.stringify)(resp) });
                span.setStatus({ code: api_1.SpanStatusCode.OK });
                span.end();
                return resp;
            }
            catch (error) {
                span.recordException(error);
                span.setStatus({ code: api_1.SpanStatusCode.ERROR });
                span.end();
                throw error;
            }
        });
    };
};
exports.patchPgQuery = patchPgQuery;
//# sourceMappingURL=patch.js.map