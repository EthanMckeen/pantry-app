"use strict";
/*
 * Copyright (c) 2024 Scale3 Labs
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.patchBuilderFunctions = void 0;
const common_1 = require("../../constants/common");
const misc_1 = require("../../utils/misc");
const trace_attributes_1 = require("@langtrase/trace-attributes");
const api_1 = require("@opentelemetry/api");
/**
 * Patch the functions of the client instance that implement the CommandBase Interface in the Weaviate client
 * Patches the do function of the builder functions to add tracingp
 * @param this any
 * @param args  PatchBuilderArgs
 */
const patchBuilderFunctions = function ({ clientInstance, clientArgs, tracer, moduleVersion, sdkName, sdkVersion }) {
    // iterate over the queryTypeToFunctionToProps object and wrap the functions
    // eslint-disable-next-line @typescript-eslint/no-this-alias
    const patchThis = this;
    Object.entries(trace_attributes_1.queryTypeToFunctionToProps).forEach(([queryType, functionsMap]) => {
        Object.entries(functionsMap).forEach(([func, properties]) => {
            const queryTypeKey = queryType;
            if (queryTypeKey in clientInstance) {
                const funcKey = func;
                if (clientInstance[queryTypeKey] !== undefined && typeof clientInstance[queryTypeKey][funcKey] === 'function') {
                    // Wrap the function with to add tracing
                    // example client.query.get
                    clientInstance[queryTypeKey][funcKey] = patchThis._wrap(clientInstance[queryTypeKey], func, (original) => {
                        return function (...originalArgs) {
                            // This is the instance that stores all the results of the different builder functions
                            const functionCallInstance = original.apply(this, originalArgs);
                            // Wrap the do function to add tracing
                            // example client.query.get.do
                            patchThis._wrap(functionCallInstance, 'do', (originalDo) => {
                                return async function (...doArgs) {
                                    const queryObj = {};
                                    properties.forEach((path) => {
                                        const value = (0, misc_1.getValueFromPath)(functionCallInstance, path);
                                        if (value !== undefined) {
                                            (0, misc_1.setValueFromPath)(queryObj, path, value);
                                        }
                                    });
                                    const customAttributes = api_1.context.active().getValue(common_1.LANGTRACE_ADDITIONAL_SPAN_ATTRIBUTES_KEY) ?? {};
                                    const collectionNameKey = functionsMap.collectionName.filter((path) => (0, misc_1.getValueFromPath)(functionCallInstance, path) !== undefined)[0];
                                    const attributes = {
                                        'langtrace.sdk.name': sdkName,
                                        'langtrace.version': sdkVersion,
                                        'langtrace.service.name': trace_attributes_1.Vendors.WEAVIATE,
                                        'langtrace.service.type': 'vectordb',
                                        'langtrace.service.version': moduleVersion,
                                        'db.system': trace_attributes_1.Vendors.WEAVIATE,
                                        'server.address': clientArgs.host,
                                        'db.operation': `${queryType}.${func}`,
                                        'db.collection.name': (0, misc_1.getValueFromPath)(functionCallInstance, collectionNameKey),
                                        'db.query': JSON.stringify(queryObj),
                                        ...customAttributes
                                    };
                                    const span = tracer.startSpan(`${queryType}.${func}.do`, { kind: api_1.SpanKind.CLIENT, attributes }, api_1.context.active());
                                    return await api_1.context.with(api_1.trace.setSpan(api_1.context.active(), span), async () => {
                                        try {
                                            const resp = await originalDo.apply(this, doArgs);
                                            if (resp !== undefined)
                                                span.addEvent(trace_attributes_1.Event.RESPONSE, { 'db.response': JSON.stringify(resp) });
                                            span.setStatus({ code: api_1.SpanStatusCode.OK });
                                            span.end();
                                            return resp;
                                        }
                                        catch (error) {
                                            span.recordException(error);
                                            span.setStatus({ code: api_1.SpanStatusCode.ERROR });
                                            span.end();
                                            throw error;
                                        }
                                    });
                                };
                            });
                            return functionCallInstance;
                        };
                    });
                }
            }
        });
    });
};
exports.patchBuilderFunctions = patchBuilderFunctions;
//# sourceMappingURL=patch.js.map