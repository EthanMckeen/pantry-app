"use strict";
/*
 * Copyright (c) 2024 Scale3 Labs
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.collectionPatch = void 0;
const common_1 = require("../../constants/common");
const trace_attributes_1 = require("@langtrase/trace-attributes");
const api_1 = require("@opentelemetry/api");
function collectionPatch(originalMethod, method, tracer, langtraceVersion, version) {
    return async function (...args) {
        // Extract custom attributes from the current context
        const customAttributes = api_1.context.active().getValue(common_1.LANGTRACE_ADDITIONAL_SPAN_ATTRIBUTES_KEY) ?? {};
        const api = trace_attributes_1.APIS.chromadb[method];
        const attributes = {
            'langtrace.sdk.name': '@langtrase/typescript-sdk',
            'langtrace.service.name': trace_attributes_1.Vendors.CHROMADB,
            'langtrace.service.type': 'vectordb',
            'langtrace.service.version': version ?? 'latest',
            'langtrace.version': langtraceVersion,
            'db.system': 'chromadb',
            'db.operation': api.OPERATION,
            'db.query': JSON.stringify(args),
            ...customAttributes
        };
        if (this.name !== undefined) {
            attributes['db.collection.name'] = this.name;
        }
        if (this.api?.basePath !== undefined) {
            attributes['server.address'] = this.api.basePath;
        }
        if (this.embeddingFunction?.model !== undefined) {
            attributes['db.chromadb.embedding_model'] = this.embeddingFunction.model;
        }
        const span = tracer.startSpan(api.METHOD, { kind: api_1.SpanKind.CLIENT, attributes }, api_1.context.active());
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        return await api_1.context.with(api_1.trace.setSpan(api_1.context.active(), span), async () => {
            try {
                // NOTE: Not tracing the response data as it can contain sensitive information
                const response = await originalMethod.apply(this, args);
                if (response !== undefined)
                    span.addEvent(trace_attributes_1.Event.RESPONSE, { 'db.response': JSON.stringify(response) });
                span.setStatus({ code: api_1.SpanStatusCode.OK });
                span.end();
                return response;
            }
            catch (error) {
                span.recordException(error);
                span.setStatus({ code: api_1.SpanStatusCode.ERROR });
                span.end();
                throw error;
            }
        });
    };
}
exports.collectionPatch = collectionPatch;
//# sourceMappingURL=patch.js.map