"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.sendUserFeedback = exports.getPromptFromRegistry = void 0;
const axios_1 = __importDefault(require("axios"));
/**
 * Fetches a prompt from the registry.
 *
 * @param promptRegistryId - The ID of the prompt registry.
 * @param options - Configuration options for fetching the prompt:
 *    - `prompt_version` - Fetches the prompt with the specified version. If not provided, the live prompt will be fetched. If there is no live prompt, an error will be thrown.
 *    - `variables`: - Replaces the variables in the prompt with the provided values. Each key of the object should be the variable name, and the corresponding value should be the value to replace.
 * @returns LangtracePrompt - The fetched prompt with variables replaced as specified.
 */
const getPromptFromRegistry = async (promptRegistryId, options) => {
    const queryParams = new URLSearchParams({ promptset_id: promptRegistryId });
    try {
        if (options?.prompt_version !== undefined) {
            queryParams.append('version', options.prompt_version.toString());
        }
        if (options?.variables !== undefined) {
            Object.entries(options.variables).forEach(([key, value]) => {
                queryParams.append(`variables.${key}`, value);
            });
        }
        const response = await axios_1.default.get(`${process.env.LANGTRACE_API_HOST}/api/promptset?${queryParams.toString()}`, { headers: { 'x-api-key': process.env.LANGTRACE_API_KEY } });
        return response.data.prompts[0];
    }
    catch (err) {
        throw Error(`An error occured when trying to get the prompt from registry ${process.env.LANGTRACE_API_HOST}/api/promptset?${queryParams.toString()} ${JSON.stringify(err.stack)}`);
    }
};
exports.getPromptFromRegistry = getPromptFromRegistry;
/**
 *
 * @param userId id of the user giving feedback
 * @param score score of the feedback
 * @param traceId traceId of the llm interaction. This is available when the inteaction is wrapped in withLangtraceRootSpan
 * @param spanId spanId of the llm interaction. This is available when the inteaction is wrapped in withLangtraceRootSpan
 *
 */
const sendUserFeedback = async ({ userId, userScore, traceId, spanId }) => {
    const evaluation = await getEvaluation(spanId).catch((err) => {
        throw err;
    });
    try {
        if (evaluation !== undefined) {
            // make a put request to update the evaluation
            await axios_1.default.put(`${process.env.LANGTRACE_API_HOST}/api/evaluation`, { userId, userScore, spanId, traceId }, { headers: { 'x-api-key': process.env.LANGTRACE_API_KEY } });
        }
        else {
            // make a post request to create a new evaluation
            await axios_1.default.post(`${process.env.LANGTRACE_API_HOST}/api/evaluation`, { userId, userScore, spanId, traceId }, { headers: { 'x-api-key': process.env.LANGTRACE_API_KEY } });
        }
    }
    catch (err) {
        throw Error(`An error occured while sending user feedback to langtrace ${process.env.LANGTRACE_API_HOST}/api/evaluation ${JSON.stringify(err.stack)}`);
    }
};
exports.sendUserFeedback = sendUserFeedback;
/**
 *
 * @param spanId spanId of the evaluation to be fetched
 * @returns LangTraceEvaluation | undefined
 */
const getEvaluation = async (spanId) => {
    try {
        const response = await axios_1.default.get(`${process.env.LANGTRACE_API_HOST}/api/evaluation?spanId=${spanId}`, { headers: { 'x-api-key': process.env.LANGTRACE_API_KEY } });
        return response.data.evaluations[0];
    }
    catch (err) {
        throw Error(`An error occured when trying to get the evaluation from langtrace ${process.env.LANGTRACE_API_HOST}/api/evaluation?spanId=${spanId} ${JSON.stringify(err.stack)}`);
    }
};
//# sourceMappingURL=langtrace.js.map